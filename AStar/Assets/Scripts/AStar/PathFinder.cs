using System.Collections.Generic;
using PriorityQueue;

namespace AStar
{
	// An enum to represent the status of the pathfinder
	public enum PathFinderStatus
	{
		NOT_INITIALIZED,
		SUCCESS,
		FAILURE,
		RUNNING,
	}

	// The Node abstract class that provides the base class for any type of vertex to implement in path finding problem.
	abstract public class Node<T>
	{
		// We store a reference to the T as Value.
		public T Value { get; private set; }

		// The constructor for the Node class.
		public Node( T value )
		{
			Value = value;
		}

		// Get the neighbours for this node. 
		abstract public List<Node<T>> GetNeighbours();
	}

	// The abstract PathFinder class that implements the core pathfinding related codes.
	abstract public class PathFinder<T>
	{
		// Create a delegate that defines the signature for calculating the cost between two Nodes (T which makes a Node)
		public delegate float CostFunction( T a, T b );
		public CostFunction HeuristicCost { get; set; }
		public CostFunction NodeTraversalCost { get; set; }

		// The PathFinderNodeclass equates to a node in a the tree generated by the pathfinder in its search for the most optimal path.
		public class PathFinderNode : System.IComparable<PathFinderNode>
		{
			// The parent of this node.
			public PathFinderNode Parent { get; set; }

			// The Node that this PathFinderNode is pointing to.
			public Node<T> Location { get; private set; }

			// The various costs.
			public float Fcost { get; private set; }
			public float GCost { get; private set; }
			public float Hcost { get; private set; }

			// The constructor.
			public PathFinderNode( Node<T> location,
				PathFinderNode parent,
				float gCost,
				float hCost )
			{
				Location = location;
				Parent = parent;
				Hcost = hCost;
				SetGCost( gCost );
			}

			// Set the gcost. 
			public void SetGCost( float c )
			{
				GCost = c;
				Fcost = GCost + Hcost;
			}

			public int CompareTo( PathFinderNode other )
			{
				if( other == null ) return 1;
				return Fcost.CompareTo( other.Fcost );
			}
		}

		// Add a property that holds the current status of the pathfinder.
		public PathFinderStatus Status
		{
			get;
			private set;
		} = PathFinderStatus.NOT_INITIALIZED;

		// Add properties for the start and goal nodes.
		public Node<T> Start { get; private set; }
		public Node<T> Goal { get; private set; }

		// The property to access the CurrentNode that the pathfinder is now at.
		public PathFinderNode CurrentNode { get; private set; }


		// The open list for the path finder.
		protected List<PathFinderNode> mOpenList = new List<PathFinderNode>();

		// The closed list
		protected List<PathFinderNode> mClosedList = new List<PathFinderNode>();

		// A helper method to find the least cost node from a list
		protected PathFinderNode GetLeastCostNode( List<PathFinderNode> myList )
		{
			int best_index = 0;
			float best_priority = myList[0].Fcost;
			for( int i = 1; i < myList.Count; i++ )
			{
				if( best_priority > myList[i].Fcost )
				{
					best_priority = myList[i].Fcost;
					best_index = i;
				}
			}

			PathFinderNode n = myList[best_index];
			return n;
		}

		// A helper method to check if a value of T is in a list.
		protected int IsInList( List<PathFinderNode> myList, T cell )
		{
			for( int i = 0; i < myList.Count; ++i )
			{
				if( EqualityComparer<T>.Default.Equals( myList[i].Location.Value, cell ) )
					return i;
			}
			return -1;
		}

		// Callbacks to handle on changes to the internal values
		public delegate void DelegatePathFinderNode( PathFinderNode node );
		public DelegatePathFinderNode onChangeCurrentNode;
		public DelegatePathFinderNode onAddToOpenList;
		public DelegatePathFinderNode onAddToClosedList;
		public DelegatePathFinderNode onDestinationFound;

		public delegate void DelegateNoArgument();
		public DelegateNoArgument onStarted;
		public DelegateNoArgument onRunning;
		public DelegateNoArgument onFailure;
		public DelegateNoArgument onSuccess;

		// Stage 1. Initialize the serach.
		public bool Initialize( Node<T> start, Node<T> goal )
		{
			if( Status == PathFinderStatus.RUNNING )
			{
				// Path finding is already in progress.
				return false;
			}

			// Reset the variables.
			Reset();

			// Set the start and the goal nodes for this search.
			Start = start;
			Goal = goal;

			// Calculate the H cost for the start.
			float H = HeuristicCost( Start.Value, Goal.Value );

			// Create a root node with its parent as null.
			PathFinderNode root = new PathFinderNode( Start, null, 0f, H );

			// add this root node to our open list.
			mOpenList.Enqueue( root );

			// set the current node to root node.
			CurrentNode = root;

			// Invoke the deletages to inform the caller if the delegates are not null.
			onChangeCurrentNode?.Invoke( CurrentNode );
			onStarted?.Invoke();

			// set the status of the pathfinder to RUNNING.
			Status = PathFinderStatus.RUNNING;

			return true;
		}

		// Stage 2: Step until success or failure
		public PathFinderStatus Step()
		{
			// Add the current node to the closed list.
			mClosedList.Add( CurrentNode );

			// Call the delegate to inform any subscribers.
			onAddToClosedList?.Invoke( CurrentNode );

			if( mOpenList.Count == 0 )
			{
				// we have exhausted our search. No solution is found.
				Status = PathFinderStatus.FAILURE;
				onFailure?.Invoke();
				return Status;
			}

			// Get the least cost element from the open list. 
			CurrentNode = mOpenList.Dequeue();

			// Call the delegate to inform any subscribers.
			onChangeCurrentNode?.Invoke( CurrentNode );

			// Check if the node contains the Goal cell.
			if( EqualityComparer<T>.Default.Equals(
				CurrentNode.Location.Value, Goal.Value ) )
			{
				Status = PathFinderStatus.SUCCESS;
				onDestinationFound?.Invoke( CurrentNode );
				onSuccess?.Invoke();
				return Status;
			}

			// Find the neighbours.
			List<Node<T>> neighbours = CurrentNode.Location.GetNeighbours();

			// Traverse each of these neighbours for possible expansion.
			foreach( Node<T> cell in neighbours )
			{
				AlgorithmSpecificImplementation( cell );
			}

			Status = PathFinderStatus.RUNNING;
			onRunning?.Invoke();
			return Status;
		}

		abstract protected void AlgorithmSpecificImplementation( Node<T> cell );

		// Reset the internal variables for a new search.
		protected void Reset()
		{
			if( Status == PathFinderStatus.RUNNING )
			{
				// Cannot reset path finder. Path finding in progress.
				return;
			}

			CurrentNode = null;

			mOpenList.Clear();
			mClosedList.Clear();

			Status = PathFinderStatus.NOT_INITIALIZED;
		}
	}


	// The AstarPathFinder.
	public class AStarPathFinder<T> : PathFinder<T>
	{
		protected override void AlgorithmSpecificImplementation( Node<T> cell )
		{
			// first of all check if the node is already in the closedlist.
			// if so then we do not need to continue search for this node.
			if( IsInList( mClosedList, cell.Value ) == -1 )
			{
				// The cell does not exist in the closed list.

				// Calculate the cost of the node from its parent.
				// Remember G is the cost from the start till now.

				float G = CurrentNode.GCost + NodeTraversalCost(CurrentNode.Location.Value, cell.Value );

				float H = HeuristicCost( cell.Value, Goal.Value );

				// Check if the cell is already there in the open list.
				int idOList = IsInList( mOpenList, cell.Value );
				if( idOList == -1 )
				{
					// The cell does not exist in the open list.
					// We will add the cell to the open list.

					PathFinderNode n = new PathFinderNode( cell, CurrentNode, G, H );
					mOpenList.Add( n );
					onAddToOpenList?.Invoke( n );
				}
				else
				{
					// if the cell exists in the openlist then check if the G cost 
					// is less than the one already in the list.
					float oldG = mOpenList[idOList].GCost;
					if( G < oldG )
					{
						// change the parent and update the cost to the new G
						mOpenList[idOList].Parent = CurrentNode;
						mOpenList[idOList].SetGCost( G );
						onAddToOpenList?.Invoke( mOpenList[idOList] );
					}
				}
			}
		}
	}
}
